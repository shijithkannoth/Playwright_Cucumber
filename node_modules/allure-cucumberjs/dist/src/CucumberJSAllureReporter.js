"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CucumberJSAllureFormatter = exports.CucumberJSAllureFormatterConfig = exports.Allure = void 0;
const os_1 = __importDefault(require("os"));
const process_1 = __importDefault(require("process"));
const cucumber_1 = require("@cucumber/cucumber");
const messages = __importStar(require("@cucumber/messages"));
const messages_1 = require("@cucumber/messages");
const allure_js_commons_1 = require("allure-js-commons");
Object.defineProperty(exports, "Allure", { enumerable: true, get: function () { return allure_js_commons_1.Allure; } });
const internal_1 = require("allure-js-commons/internal");
const CucumberAllureWorld_1 = require("./CucumberAllureWorld");
class CucumberJSAllureFormatterConfig {
}
exports.CucumberJSAllureFormatterConfig = CucumberJSAllureFormatterConfig;
const { ALLURE_HOST_NAME, ALLURE_THREAD_NAME } = process_1.default.env;
class CucumberJSAllureFormatter extends cucumber_1.Formatter {
    constructor(options, allureRuntime, config) {
        super(options);
        this.allureRuntime = allureRuntime;
        this.currentTestsMap = new Map();
        this.hostname = ALLURE_HOST_NAME || os_1.default.hostname();
        this.documentMap = new Map();
        this.scenarioMap = new Map();
        this.stepMap = new Map();
        this.testStepMap = new Map();
        this.pickleStepMap = new Map();
        this.testCaseTestStepsResults = new Map();
        this.pickleMap = new Map();
        this.hookMap = new Map();
        this.sourceMap = new Map();
        this.testCaseMap = new Map();
        this.testCaseStartedMap = new Map();
        this.allureSteps = new Map();
        this.convertStatus = (status) => {
            switch (status) {
                case messages_1.TestStepResultStatus.FAILED:
                    return allure_js_commons_1.Status.FAILED;
                case messages_1.TestStepResultStatus.PASSED:
                    return allure_js_commons_1.Status.PASSED;
                case messages_1.TestStepResultStatus.SKIPPED:
                case messages_1.TestStepResultStatus.PENDING:
                    return allure_js_commons_1.Status.SKIPPED;
                default:
                    return undefined;
            }
        };
        options.eventBroadcaster.on("envelope", this.parseEnvelope.bind(this));
        this.labelsMatchers = config.labels || [];
        this.linksMatchers = config.links || [];
        this.exceptionFormatter = (message) => {
            if (!message || !config.exceptionFormatter) {
                return message;
            }
            try {
                return config.exceptionFormatter(message);
            }
            catch (e) {
                console.warn(`Error in exceptionFormatter: ${e}`);
                return message;
            }
        };
        if (options.supportCodeLibrary.World === cucumber_1.World) {
            options.supportCodeLibrary.World = CucumberAllureWorld_1.CucumberAllureWorld;
        }
        this.beforeHooks = options.supportCodeLibrary.beforeTestCaseHookDefinitions;
        this.afterHooks = options.supportCodeLibrary.afterTestCaseHookDefinitions;
    }
    get tagsIgnorePatterns() {
        const { linksMatchers, labelsMatchers } = this;
        return [...linksMatchers, ...labelsMatchers].flatMap(({ pattern }) => pattern);
    }
    parseEnvelope(envelope) {
        if (envelope.gherkinDocument) {
            this.onGherkinDocument(envelope.gherkinDocument);
        }
        else if (envelope.pickle) {
            this.onPickle(envelope.pickle);
        }
        else if (envelope.testCase) {
            this.onTestCase(envelope.testCase);
        }
        else if (envelope.testCaseStarted) {
            this.onTestCaseStarted(envelope.testCaseStarted);
        }
        else if (envelope.testCaseFinished) {
            this.onTestCaseFinished(envelope.testCaseFinished);
        }
        else if (envelope.attachment) {
            this.onAttachment(envelope.attachment);
        }
        else if (envelope.hook) {
            this.onHook(envelope.hook);
        }
        else if (envelope.source) {
            this.onSource(envelope.source);
        }
        else if (envelope.testStepStarted) {
            this.onTestStepStarted(envelope.testStepStarted);
        }
        else if (envelope.testStepFinished) {
            this.onTestStepFinished(envelope.testStepFinished);
        }
    }
    parseTagsLabels(tags) {
        const labels = [];
        if (this.labelsMatchers.length === 0) {
            return labels;
        }
        this.labelsMatchers.forEach((matcher) => {
            const matchedTags = tags.filter((tag) => matcher.pattern.some((pattern) => pattern.test(tag.name)));
            const matchedLabels = matchedTags.map((tag) => {
                const tagValue = tag.name.replace(/^@\S+:/, "");
                return {
                    name: matcher.name,
                    value: tagValue,
                };
            });
            labels.push(...matchedLabels);
        });
        return labels;
    }
    parseTagsLinks(tags) {
        const tagKeyRe = /^@\S+=/;
        const links = [];
        if (this.linksMatchers.length === 0) {
            return links;
        }
        this.linksMatchers.forEach((matcher) => {
            const matchedTags = tags.filter((tag) => matcher.pattern.some((pattern) => pattern.test(tag.name)));
            const matchedLinks = matchedTags.map((tag) => {
                const tagValue = tag.name.replace(tagKeyRe, "");
                return {
                    url: matcher.urlTemplate.replace(/%s$/, tagValue) || tagValue,
                    type: matcher.type,
                };
            });
            links.push(...matchedLinks);
        });
        return links;
    }
    onGherkinDocument(data) {
        var _a, _b;
        if (data.uri) {
            this.documentMap.set(data.uri, data);
        }
        (_b = (_a = data.feature) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.forEach((c) => {
            if (c.rule) {
                this.onRule(c.rule);
            }
            else if (c.scenario) {
                this.onScenario(c.scenario);
            }
        });
    }
    onRule(data) {
        var _a;
        (_a = data.children) === null || _a === void 0 ? void 0 : _a.forEach((c) => {
            if (c.scenario) {
                this.onScenario(c.scenario);
            }
        });
    }
    onScenario(data) {
        this.scenarioMap.set(data.id, data);
        data.steps.forEach((step) => this.stepMap.set(step.id, step));
    }
    onPickle(data) {
        this.pickleMap.set(data.id, data);
        data.steps.forEach((ps) => this.pickleStepMap.set(ps.id, ps));
    }
    onTestCase(data) {
        this.testCaseMap.set(data.id, data);
        data.testSteps.forEach((ts) => this.testStepMap.set(ts.id, ts));
    }
    onTestCaseStarted(data) {
        var _a, _b, _c, _d, _e, _f;
        const testCase = this.testCaseMap.get(data.testCaseId);
        if (!testCase) {
            console.error("onTestCaseStarted", "test case not found", data);
            return;
        }
        const pickle = this.pickleMap.get(testCase.pickleId);
        if (!pickle) {
            console.error("onTestCaseStarted", "pickle not found", data);
            return;
        }
        const doc = this.documentMap.get(pickle.uri);
        const featureLabels = this.parseTagsLabels(((_a = doc === null || doc === void 0 ? void 0 : doc.feature) === null || _a === void 0 ? void 0 : _a.tags) || []);
        const featureLinks = this.parseTagsLinks(((_b = doc === null || doc === void 0 ? void 0 : doc.feature) === null || _b === void 0 ? void 0 : _b.tags) || []);
        const scenarioId = (_c = pickle === null || pickle === void 0 ? void 0 : pickle.astNodeIds) === null || _c === void 0 ? void 0 : _c[0];
        const scenario = this.scenarioMap.get(scenarioId);
        const scenarioLabels = this.parseTagsLabels((scenario === null || scenario === void 0 ? void 0 : scenario.tags) || []);
        const scenarioLinks = this.parseTagsLinks((scenario === null || scenario === void 0 ? void 0 : scenario.tags) || []);
        const currentTest = new allure_js_commons_1.AllureTest(this.allureRuntime, Date.now());
        const thread = data.workerId || ALLURE_THREAD_NAME || process_1.default.pid.toString();
        const fullName = `${pickle.uri}#${pickle.name}`;
        const description = (scenario === null || scenario === void 0 ? void 0 : scenario.description) || ((_d = doc === null || doc === void 0 ? void 0 : doc.feature) === null || _d === void 0 ? void 0 : _d.description) || "";
        const testCaseId = (0, allure_js_commons_1.md5)(fullName);
        this.testCaseStartedMap.set(data.id, data);
        this.testCaseTestStepsResults.set(data.id, []);
        this.currentTestsMap.set(data.id, currentTest);
        currentTest.name = pickle.name;
        currentTest.description = description.trim();
        currentTest.fullName = fullName;
        currentTest.testCaseId = testCaseId;
        currentTest.addLabel(allure_js_commons_1.LabelName.HOST, this.hostname);
        currentTest.addLabel(allure_js_commons_1.LabelName.LANGUAGE, "javascript");
        currentTest.addLabel(allure_js_commons_1.LabelName.FRAMEWORK, "cucumberjs");
        currentTest.addLabel(allure_js_commons_1.LabelName.THREAD, thread);
        featureLabels.forEach((label) => currentTest.addLabel(label.name, label.value));
        featureLinks.forEach((link) => currentTest.addLink(link.url, link.name, link.type));
        scenarioLabels.forEach((label) => currentTest.addLabel(label.name, label.value));
        scenarioLinks.forEach((link) => currentTest.addLink(link.url, link.name, link.type));
        if (doc === null || doc === void 0 ? void 0 : doc.feature) {
            currentTest.addLabel(allure_js_commons_1.LabelName.FEATURE, doc.feature.name);
        }
        if (scenario) {
            currentTest.addLabel(allure_js_commons_1.LabelName.SUITE, scenario.name);
        }
        if ((_e = pickle.tags) === null || _e === void 0 ? void 0 : _e.length) {
            const filteredTags = pickle.tags.filter((tag) => !this.tagsIgnorePatterns.some((pattern) => pattern.test(tag.name)));
            filteredTags.forEach((tag) => currentTest.addLabel(allure_js_commons_1.LabelName.TAG, tag.name));
        }
        if (!((_f = scenario === null || scenario === void 0 ? void 0 : scenario.examples) === null || _f === void 0 ? void 0 : _f.length)) {
            return;
        }
        scenario.examples.forEach((example) => {
            var _a;
            const csvDataTableHeader = ((_a = example === null || example === void 0 ? void 0 : example.tableHeader) === null || _a === void 0 ? void 0 : _a.cells.map((cell) => cell.value).join(",")) || "";
            const csvDataTableBody = (example === null || example === void 0 ? void 0 : example.tableBody.map((row) => row.cells.map((cell) => cell.value).join(",")).join("\n")) ||
                "";
            if (!csvDataTableHeader && !csvDataTableBody) {
                return;
            }
            const csvDataTable = `${csvDataTableHeader}\n${csvDataTableBody}\n`;
            const attachmentFilename = this.allureRuntime.writeAttachment(csvDataTable, allure_js_commons_1.ContentType.CSV);
            currentTest.addAttachment("Examples", {
                contentType: allure_js_commons_1.ContentType.CSV,
            }, attachmentFilename);
        });
    }
    onAttachment(data) {
        const currentTest = this.currentTestsMap.get((data === null || data === void 0 ? void 0 : data.testCaseStartedId) || "");
        if (!currentTest) {
            return;
        }
        const currentStep = this.allureSteps.get((data === null || data === void 0 ? void 0 : data.testStepId) || "");
        if (!data) {
            console.error("onAttachment", "attachment can't be empty");
            return;
        }
        const { fileName = "attachment", body, mediaType, contentEncoding } = data;
        if (mediaType === internal_1.ALLURE_METADATA_CONTENT_TYPE) {
            this.handleAllureAttachment({
                test: currentTest,
                step: currentStep,
                metadata: JSON.parse(body),
            });
            return;
        }
        const encoding = Buffer.isEncoding(contentEncoding) ? contentEncoding : undefined;
        const attachmentFilename = this.allureRuntime.writeAttachment(body, mediaType, encoding);
        (currentStep !== null && currentStep !== void 0 ? currentStep : currentTest).addAttachment(fileName, {
            contentType: mediaType,
        }, attachmentFilename);
    }
    handleAllureAttachment(payload) {
        payload.test.applyMetadata(payload.metadata, (step) => {
            if (payload.step) {
                payload.step.addStep(step);
                return;
            }
            payload.test.addStep(step);
        });
    }
    onTestCaseFinished(data) {
        const currentTest = this.currentTestsMap.get(data.testCaseStartedId);
        if (!currentTest) {
            console.error("onTestCaseFinished", "current test not found", data);
            return;
        }
        const testCaseStarted = this.testCaseStartedMap.get(data.testCaseStartedId);
        if (!testCaseStarted) {
            console.error("onTestCaseFinished", "testCaseStarted event not found", data);
            return;
        }
        const testCase = this.testCaseMap.get(testCaseStarted.testCaseId);
        if (!testCase) {
            console.error("onTestCaseFinished", "testCase not found", data);
            return;
        }
        const pickle = this.pickleMap.get(testCase.pickleId);
        if (!pickle) {
            console.error("onTestCaseFinished", "pickle not found", data);
            return;
        }
        const testStepResults = this.testCaseTestStepsResults.get(testCaseStarted.id);
        if (testStepResults === null || testStepResults === void 0 ? void 0 : testStepResults.length) {
            const worstTestStepResult = messages.getWorstTestStepResult(testStepResults);
            currentTest.status = currentTest.isAnyStepFailed
                ? allure_js_commons_1.Status.FAILED
                : this.convertStatus(worstTestStepResult.status);
            const message = this.exceptionFormatter(currentTest.status
                ? worstTestStepResult.message
                : "The test doesn't have an implementation.");
            currentTest.statusDetails = {
                message,
            };
        }
        else {
            currentTest.status = allure_js_commons_1.Status.PASSED;
        }
        currentTest.calculateHistoryId();
        currentTest.endTest(Date.now());
        this.currentTestsMap.delete(data.testCaseStartedId);
    }
    onHook(data) {
        this.hookMap.set(data.id, data);
    }
    onSource(data) {
        if (data.uri) {
            this.sourceMap.set(data.uri, data);
        }
    }
    onTestStepStarted(data) {
        const currentTest = this.currentTestsMap.get(data.testCaseStartedId);
        if (!currentTest) {
            return;
        }
        const testStep = this.testStepMap.get(data.testStepId);
        if (!testStep) {
            console.error("onTestStepStarted", "can't find step", data);
            return;
        }
        if (testStep.pickleStepId) {
            const ps = this.pickleStepMap.get(testStep.pickleStepId);
            if (!ps) {
                return;
            }
            const keyword = ps.astNodeIds
                .map((astNodeId) => this.stepMap.get(astNodeId))
                .map((step) => step === null || step === void 0 ? void 0 : step.keyword)
                .find((kw) => kw !== undefined) || "";
            const { argument } = ps;
            const allureStep = currentTest.startStep(keyword + ps.text, Date.now());
            this.allureSteps.set(data.testStepId, allureStep);
            if (!(argument === null || argument === void 0 ? void 0 : argument.dataTable)) {
                return;
            }
            const csvDataTable = argument.dataTable.rows.reduce((acc, row) => `${acc + row.cells.map((cell) => cell.value).join(",")}\n`, "");
            const attachmentFilename = this.allureRuntime.writeAttachment(csvDataTable, allure_js_commons_1.ContentType.CSV);
            allureStep.addAttachment("Data table", {
                contentType: allure_js_commons_1.ContentType.CSV,
            }, attachmentFilename);
        }
    }
    onTestStepFinished(data) {
        var _a;
        const currentTest = this.currentTestsMap.get(data.testCaseStartedId);
        (_a = this.testCaseTestStepsResults.get(data.testCaseStartedId)) === null || _a === void 0 ? void 0 : _a.push(data.testStepResult);
        if (!currentTest) {
            return;
        }
        const allureStep = this.allureSteps.get(data.testStepId);
        if (!allureStep) {
            return;
        }
        allureStep.status = this.convertStatus(data.testStepResult.status);
        allureStep.detailsMessage = this.exceptionFormatter(allureStep.status ? data.testStepResult.message : "The step doesn't have an implementation.");
        allureStep.endStep(Date.now());
    }
}
exports.CucumberJSAllureFormatter = CucumberJSAllureFormatter;
//# sourceMappingURL=CucumberJSAllureReporter.js.map